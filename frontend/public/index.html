<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <!-- Required for Relayer WASM workers -->
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin"/>
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp"/>
  <title>Anonymous P2P Arbitration Scoring · Zama FHEVM</title>
  <meta name="description" content="Trust without history: encrypted scores in, aggregate + tier verdict out. Zama FHEVM + Relayer SDK 0.3.0."/>

  <!-- Distinct visual: daylight pastel + soft grid -->
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=General+Sans:wght@500;700;800&family=Chivo+Mono:wght@600&display=swap" rel="stylesheet"/>
  <style>
    :root{
      --bg:#fbfaf7; --paper:#ffffff; --ink:#0f172a; --muted:#5f6c7b; --line:#e8ecef;
      --rose:#e76f51; --mint:#2a9d8f; --amber:#f4a261; --blue:#3a86ff; --vio:#845ef7;
      --mono:"Chivo Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      --sans:"General Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica Neue, Arial, sans-serif;
      --r:18px; --shadow:0 22px 60px rgba(15,23,42,.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1000px 600px at 10% -10%, rgba(132,94,247,.10), transparent 45%),
                      radial-gradient(900px 600px at 110% 0%, rgba(58,134,255,.10), transparent 55%),
                      linear-gradient(180deg,#fefefe,#fbfaf7);
         color:var(--ink);font-family:var(--sans)}
    header{position:sticky;top:0;z-index:30;background:rgba(255,255,255,.75);backdrop-filter:blur(10px);border-bottom:1px solid var(--line)}
    .bar{max-width:1180px;margin:0 auto;padding:14px 18px;display:flex;align-items:center;justify-content:space-between}
    .brand{display:flex;align-items:center;gap:12px}
    .badge{width:44px;height:44px;border-radius:14px;background:conic-gradient(from 200deg,#3a86ff,#845ef7,#2a9d8f,#3a86ff);display:grid;place-items:center;box-shadow:inset 0 0 0 1px rgba(15,23,42,.06)}
    .badge span{font:800 12px var(--mono);color:#0f172a}
    .title{margin:0;font:800 22px var(--sans);letter-spacing:.2px}
    .sub{margin:0;color:var(--muted);font:700 12px var(--mono)}

    .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .chip{border:1px solid var(--line);background:#fff;border-radius:999px;padding:6px 10px;font:700 12px var(--mono);color:#334155}
    .btn{appearance:none;border:1px solid var(--line);background:#fff;color:#0f172a;border-radius:14px;padding:10px 14px;font-weight:800;cursor:pointer;transition:.15s;box-shadow:var(--shadow)}
    .btn:hover{transform:translateY(-1px)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .btn-pri{background:linear-gradient(180deg,#3a86ff,#2557d6);color:#fff;border-color:#3a86ff}

    main{max-width:1180px;margin:24px auto 60px;padding:0 18px}
    .grid{display:grid;grid-template-columns:1.15fr .85fr;gap:22px}
    @media (max-width:1000px){.grid{grid-template-columns:1fr}}

    .card{background:var(--paper);border:1px solid var(--line);border-radius:var(--r);padding:18px;box-shadow:var(--shadow)}
    .card h2{margin:0 0 6px;font:800 18px var(--sans)}
    .note{font:700 12px var(--mono);color:var(--muted)}

    .rows{display:grid;gap:10px}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width:720px){.two{grid-template-columns:1fr}}

    label{font:800 11px var(--mono);color:#475569;letter-spacing:.06em}
    input{width:100%;padding:12px 14px;border:1px solid var(--line);border-radius:14px;background:#fff;outline:none;font:800 14px var(--sans)}
    input:focus{box-shadow:0 0 0 4px rgba(58,134,255,.15)}

    .status{margin-top:10px;border:1px dashed var(--line);background:#fff;border-radius:14px;padding:12px;min-height:48px;display:flex;align-items:center;justify-content:center;font:700 12px var(--mono);color:#475569}
    .status.ok{border-color:rgba(42,157,143,.35);color:#2a9d8f}
    .status.err{border-color:rgba(231,111,81,.35);color:#e76f51}

    .handles{font:700 12px var(--mono);color:#0f172a;background:#f8fafc;border:1px dashed var(--line);border-radius:14px;padding:10px;word-break:break-all}
    .tier{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid var(--line);font:800 12px var(--mono)}
    .t0{color:#64748b}
    .t1{color:#8b5cf6}
    .t2{color:#2563eb}
    .t3{color:#16a34a}
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="brand">
        <div class="badge"><span>FHE</span></div>
        <div>
          <div class="title">Anonymous P2P Arbitration Scoring</div>
          <div class="sub">Trust without history · Zama FHEVM · Relayer 0.2.0</div>
        </div>
      </div>
      <div class="row">
        <span id="netChip" class="chip">Network: —</span>
        <span id="addrChip" class="chip">Contract: —</span>
        <button id="btnConnect" class="btn btn-pri">Connect Wallet</button>
      </div>
    </div>
  </header>

  <main>
    <section class="grid">
      <!-- LEFT: Raters / Public -->
      <article class="card">
        <h2>Submit Encrypted Score</h2>
        <p class="note">Anyone can submit a private score (0..100) for a target. Only aggregate is kept; raters aren't stored.</p>
        <div class="rows">
          <div class="two">
            <div>
              <label>Target Address</label>
              <input id="target" type="text" placeholder="0xRecipient..."/>
            </div>
            <div>
              <label>Score (0..100)</label>
              <input id="score" type="number" min="0" max="100" placeholder="85"/>
            </div>
          </div>
          <div class="row">
            <button id="btnSubmit" class="btn">Submit Score (encrypted)</button>
            <span id="subTx" class="chip">TX: —</span>
          </div>
          <div id="leftLog" class="status">Ready</div>
        </div>

        <div style="height:10px"></div>
        <h2>Aggregate</h2>
        <p class="note">Publish & decrypt the encrypted sum for off‑chain average; count is plain.</p>
        <div class="row">
          <button id="btnGetAgg" class="btn">Get Handles</button>
          <button id="btnPublishSum" class="btn">Publish Sum</button>
          <button id="btnDecryptSum" class="btn">Decrypt Sum</button>
          <span id="avgChip" class="chip">Avg: —</span>
        </div>
        <div id="aggHandles" class="handles">sum: —\ncount: —</div>
        <div id="aggLog" class="status">—</div>
      </article>

      <!-- RIGHT: Owner Policy & Verdict -->
      <article class="card">
        <h2>Policy (Owner)</h2>
        <p class="note">Min average thresholds for tiers. Upload as encrypted values (0..100).</p>
        <div class="rows">
          <div class="two">
            <div>
              <label>Bronze ≥</label>
              <input id="bronze" type="number" min="0" max="100" placeholder="50"/>
            </div>
            <div>
              <label>Silver ≥</label>
              <input id="silver" type="number" min="0" max="100" placeholder="70"/>
            </div>
          </div>
          <div class="two">
            <div>
              <label>Gold ≥</label>
              <input id="gold" type="number" min="0" max="100" placeholder="90"/>
            </div>
            <div style="display:flex;align-items:flex-end;gap:10px">
              <button id="btnSetPolicy" class="btn">Set Encrypted</button>
              <button id="btnMakePolicyPublic" class="btn">Make Policy Public</button>
            </div>
          </div>
          <div id="polHandles" class="handles">bronze: —\nsilver: —\ngold: —</div>
          <div class="two">
            <div>
              <label>Owner (current)</label>
              <input id="ownerAddr" type="text" disabled placeholder="0xOwner…"/>
            </div>
            <div>
              <label>Transfer Ownership</label>
              <div style="display:flex; gap:10px">
                <input id="newOwner" type="text" placeholder="0xNewOwner…"/>
                <button id="btnTransfer" class="btn">Transfer</button>
              </div>
            </div>
          </div>
          <div id="adminLog" class="status">Owner-only actions. Connect wallet.</div>
        </div>

        <div style="height:10px"></div>
        <h2>Verdict</h2>
        <p class="note">Tier code: 0=None, 1=Bronze, 2=Silver, 3=Gold.</p>
        <div class="rows">
          <div class="two">
            <div>
              <label>Target Address</label>
              <input id="vTarget" type="text" placeholder="0xRecipient..."/>
            </div>
            <div style="display:flex;align-items:flex-end;gap:10px">
              <button id="btnVerdictPriv" class="btn">Private</button>
              <button id="btnVerdictPub" class="btn">Public</button>
            </div>
          </div>
          <div class="row">
            <span id="tierBadge" class="tier t0">Tier: —</span>
          </div>
          <div id="verLog" class="status">—</div>
        </div>
      </article>
    </section>
  </main>

  <footer class="bar" style="background:transparent;border:0;justify-content:flex-start;gap:10px">
    <span class="chip">Ethers v6 (ESM)</span>
    <span class="chip">Relayer SDK 0.2.0</span>
    <span class="chip">Contract: <span id="addrFoot"></span></span>
  </footer>

  <!-- SDKs (ESM) -->
  <script type="module" crossorigin src="https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm"></script>

  <script type="module">
    import { BrowserProvider, Contract } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";
    import { initSDK, createInstance, SepoliaConfig, generateKeypair } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";

    // ===== App Config =====
    const CONTRACT_ADDRESS = "0x833cd7a88CFc94E672f76ca32243C994E0654F57"; // deployed
    const RELAYER_URL = "https://relayer.testnet.zama.org";
    const CHAIN_ID_HEX = "0xaa36a7"; // Sepolia

    // ===== ABI (AnonymousArbScoring) =====
    const abi = [
      { inputs: [], name: "version", outputs: [{ type: "string" }], stateMutability: "pure", type: "function" },
      { inputs: [], name: "owner", outputs: [{ type: "address" }], stateMutability: "view", type: "function" },

      { inputs: [ { name: "bronzeMinExt", type: "bytes32" }, { name: "silverMinExt", type: "bytes32" }, { name: "goldMinExt", type: "bytes32" }, { name: "proof", type: "bytes" } ], name: "setPolicyEncrypted", outputs: [], stateMutability: "nonpayable", type: "function" },
      { inputs: [], name: "makePolicyPublic", outputs: [], stateMutability: "nonpayable", type: "function" },
      { inputs: [], name: "getPolicyHandles", outputs: [ { type: "bytes32" }, { type: "bytes32" }, { type: "bytes32" } ], stateMutability: "view", type: "function" },
      { inputs: [{ name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" },

      { inputs: [ { name: "target", type: "address" }, { name: "scoreExt", type: "bytes32" }, { name: "proof", type: "bytes" } ], name: "submitScore", outputs: [], stateMutability: "nonpayable", type: "function" },

      { inputs: [ { name: "target", type: "address" } ], name: "getAggregateHandles", outputs: [ { type: "bytes32" }, { type: "uint16" } ], stateMutability: "view", type: "function" },
      { inputs: [ { name: "target", type: "address" } ], name: "publishSum", outputs: [ { type: "bytes32" } ], stateMutability: "nonpayable", type: "function" },

      { inputs: [ { name: "target", type: "address" } ], name: "verdictPrivate", outputs: [ { type: "bytes1" } ], stateMutability: "nonpayable", type: "function" },
      { inputs: [ { name: "target", type: "address" } ], name: "verdictPublic",  outputs: [ { type: "bytes1" } ], stateMutability: "nonpayable", type: "function" },

      // events
      { anonymous:false, inputs:[{indexed:true,name:"target",type:"address"},{indexed:false,name:"newCount",type:"uint16"},{indexed:false,name:"sumHandle",type:"bytes32"}], name:"Scored", type:"event" },
      { anonymous:false, inputs:[{indexed:true,name:"target",type:"address"},{indexed:false,name:"sumHandle",type:"bytes32"}], name:"SumPublished", type:"event" },
      { anonymous:false, inputs:[{indexed:true,name:"caller",type:"address"},{indexed:true,name:"target",type:"address"},{indexed:false,name:"verdictHandle",type:"bytes32"}], name:"VerdictPrivate", type:"event" },
      { anonymous:false, inputs:[{indexed:true,name:"caller",type:"address"},{indexed:true,name:"target",type:"address"},{indexed:false,name:"verdictHandle",type:"bytes32"}], name:"VerdictPublic",  type:"event" }
    ];

    // ===== Elements =====
    const $ = (id) => document.getElementById(id);
    const els = {
      btnConnect: $("btnConnect"), netChip: $("netChip"), addrChip: $("addrChip"), addrFoot: $("addrFoot"),
      target: $("target"), score: $("score"), btnSubmit: $("btnSubmit"), subTx: $("subTx"), leftLog: $("leftLog"),
      btnGetAgg: $("btnGetAgg"), btnPublishSum: $("btnPublishSum"), btnDecryptSum: $("btnDecryptSum"), aggHandles: $("aggHandles"), aggLog: $("aggLog"), avgChip: $("avgChip"),
      bronze: $("bronze"), silver: $("silver"), gold: $("gold"), btnSetPolicy: $("btnSetPolicy"), btnMakePolicyPublic: $("btnMakePolicyPublic"), polHandles: $("polHandles"), adminLog: $("adminLog"),
      vTarget: $("vTarget"), btnVerdictPriv: $("btnVerdictPriv"), btnVerdictPub: $("btnVerdictPub"), tierBadge: $("tierBadge"), verLog: $("verLog"), ownerAddr: $("ownerAddr"), newOwner: $("newOwner"), btnTransfer: $("btnTransfer"),
    };

    els.addrChip.textContent = `Contract: ${CONTRACT_ADDRESS}`;
    els.addrFoot.textContent = CONTRACT_ADDRESS;

    // ===== State =====
    let provider, signer, user, contract, relayer, isOwner=false;
    let lastSumHandleByTarget = new Map();

    const LOG = {
      info:(el, s) => { el.textContent = s; el.className = "status"; console.log("[INFO]", s); },
      ok:(el, s)   => { el.textContent = s; el.className = "status ok"; console.log("[OK]", s); },
      err:(el, s)  => { el.textContent = s; el.className = "status err"; console.error("[ERR]", s); },
    };

    // ===== Bind =====
    els.btnConnect.addEventListener('click', connect);
    els.btnSubmit.addEventListener('click', submitScore);
    els.btnGetAgg.addEventListener('click', getAgg);
    els.btnPublishSum.addEventListener('click', publishSum);
    els.btnDecryptSum.addEventListener('click', decryptSum);
    els.btnSetPolicy.addEventListener('click', setPolicy);
    els.btnMakePolicyPublic.addEventListener('click', makePolicyPublic);
    els.btnVerdictPriv.addEventListener('click', verdictPrivate);
    els.btnVerdictPub.addEventListener('click', verdictPublic);
    els.btnTransfer.addEventListener('click', transferOwnership);

    // ===== Connect =====
    async function connect(){
      try{
        if(!window.ethereum) throw new Error("MetaMask not found");
        provider = new BrowserProvider(window.ethereum);
        await provider.send('eth_requestAccounts', []);
        let net = await provider.getNetwork();
        if(net.chainId !== 11155111n){ await provider.send('wallet_switchEthereumChain', [{ chainId: CHAIN_ID_HEX }]); net = await provider.getNetwork(); }
        els.netChip.textContent = `Network: Sepolia (${String(net.chainId)})`;

        signer = await provider.getSigner();
        user = await signer.getAddress();
        els.btnConnect.textContent = `${user.slice(0,6)}…${user.slice(-4)}`;
        els.btnConnect.disabled = true;

        contract = new Contract(CONTRACT_ADDRESS, abi, signer);

        await initSDK();
        relayer = await createInstance({ ...SepoliaConfig, relayerUrl: RELAYER_URL, network: window.ethereum, debug:true });

        try{ const o = await contract.owner(); els.ownerAddr.value = o; isOwner = (o.toLowerCase()===user.toLowerCase()); }catch{}
        els.btnSetPolicy.disabled = !isOwner; els.btnMakePolicyPublic.disabled = !isOwner; els.btnTransfer.disabled = !isOwner;
        els.adminLog.textContent = isOwner ? "Owner detected ✓" : "You are not the owner — owner actions disabled";
        await showPolicyHandles();
      }catch(e){ alert(e.message || String(e)); }
    }

    // ===== Helpers =====
    const isAddr = (s)=> /^0x[a-fA-F0-9]{40}$/.test(String(s||""));
    const in01 = (n)=>{ const x = Number(n); return Number.isFinite(x) && x>=0 && x<=100; };

    async function showPolicyHandles(){
      try{ const [b,s,g] = await contract.getPolicyHandles(); els.polHandles.textContent = `bronze: ${b}\nsilver: ${s}\ngold: ${g}`; }catch{}
    }

    function renderTier(code){
      const n = Number(code||0); const map = ['None','Bronze','Silver','Gold'];
      els.tierBadge.textContent = `Tier: ${map[n]??'—'} (${n})`;
      els.tierBadge.className = `tier t${Math.min(3,Math.max(0,n))}`;
    }

    // ===== Owner Policy =====
    async function setPolicy(){
      try{
        if(!isOwner) throw new Error('Owner only');
        const b = Number(els.bronze.value||"0"), s = Number(els.silver.value||"0"), g = Number(els.gold.value||"0");
        if(!in01(b)||!in01(s)||!in01(g)) throw new Error('0..100 only');
        LOG.info(els.adminLog, 'Encrypting policy…');
        const buf = relayer.createEncryptedInput(CONTRACT_ADDRESS, user);
        buf.add16(b); buf.add16(s); buf.add16(g);
        const { handles, inputProof } = await buf.encrypt();

        // best-effort simulation
        try{ await contract.setPolicyEncrypted.staticCall(handles[0], handles[1], handles[2], inputProof); }catch{}

        // try normal send first
        try {
          const tx = await contract.setPolicyEncrypted(handles[0], handles[1], handles[2], inputProof);
          els.adminLog.textContent = `TX: ${tx.hash}`; await tx.wait(); LOG.ok(els.adminLog, 'Policy set ✓');
        } catch (e) {
          const msg = (e?.shortMessage||e?.message||'').toLowerCase();
          const isEstFail = msg.includes('estimate') || msg.includes('missing revert data') || msg.includes('gas');
          if(!isEstFail) throw e;
          LOG.info(els.adminLog, 'Retry with manual gasLimit…');
          const tx = await contract.setPolicyEncrypted(handles[0], handles[1], handles[2], inputProof, { gasLimit: 900000n });
          els.adminLog.textContent = `TX: ${tx.hash}`; await tx.wait(); LOG.ok(els.adminLog, 'Policy set ✓');
        }

        await showPolicyHandles();
      }catch(e){ LOG.err(els.adminLog, e.message||String(e)); }
    }

    async function makePolicyPublic(){
      try{
        if(!isOwner) throw new Error('Owner only');
        const tx = await contract.makePolicyPublic(); els.adminLog.textContent = `TX: ${tx.hash}`; await tx.wait(); LOG.ok(els.adminLog, 'Policy public ✓');
      }catch(e){ LOG.err(els.adminLog, e.message||String(e)); }
    }

    async function transferOwnership(){
      try{
        if(!isOwner) throw new Error('Owner only');
        const addr = (els.newOwner.value||'').trim(); if(!isAddr(addr)) throw new Error('Enter valid 0x address');
        const tx = await contract.transferOwnership(addr); els.adminLog.textContent = `TX: ${tx.hash}`; await tx.wait();
        LOG.ok(els.adminLog, 'Ownership transferred'); await connect();
      }catch(e){ LOG.err(els.adminLog, e.message||String(e)); }
    }

    // ===== Submit score =====
    async function submitScore(){
      try{
        if(!contract) await connect();
        const t = (els.target.value||"").trim(); if(!isAddr(t)) throw new Error('Enter target address');
        const sc = Number(els.score.value||"0"); if(!in01(sc)) throw new Error('Score 0..100');
        LOG.info(els.leftLog, 'Encrypting score…');
        const buf = relayer.createEncryptedInput(CONTRACT_ADDRESS, user);
        buf.add16(sc);
        const { handles, inputProof } = await buf.encrypt();
        try{ await contract.submitScore.staticCall(t, handles[0], inputProof); }catch{}
        const tx = await contract.submitScore(t, handles[0], inputProof);
        els.subTx.textContent = `TX: ${tx.hash}`; await tx.wait(); LOG.ok(els.leftLog, 'Score submitted ✓');
      }catch(e){ LOG.err(els.leftLog, e.message||String(e)); }
    }

    // ===== Aggregate =====
    async function getAgg(){
      try{
        const t = (els.target.value||"").trim(); if(!isAddr(t)) throw new Error('Enter target address');
        const [sumH, cnt] = await contract.getAggregateHandles(t);
        els.aggHandles.textContent = `sum: ${sumH}\ncount: ${cnt}`;
        LOG.ok(els.aggLog, 'Handles fetched');
      }catch(e){ LOG.err(els.aggLog, e.message||String(e)); }
    }

    async function publishSum(){
      try{
        const t = (els.target.value||"").trim(); if(!isAddr(t)) throw new Error('Enter target address');
        LOG.info(els.aggLog, 'Publishing sum…');
        const tx = await contract.publishSum(t); els.aggLog.textContent = `TX: ${tx.hash}`; const rcpt = await tx.wait();
        try{ const [sumH] = await contract.getAggregateHandles(t); lastSumHandleByTarget.set(t.toLowerCase(), sumH); }catch{}
        LOG.ok(els.aggLog, 'Sum published ✓');
      }catch(e){ LOG.err(els.aggLog, e.message||String(e)); }
    }

    async function decryptSum(){
      try{
        const t = (els.target.value||"").trim(); if(!isAddr(t)) throw new Error('Enter target address');
        const [sumH, cnt] = await contract.getAggregateHandles(t);
        const handle = lastSumHandleByTarget.get(t.toLowerCase()) || sumH;
        if(!handle || /^0x0+$/.test(String(handle))) { LOG.info(els.aggLog, 'No published sum — click "Publish Sum"'); return; }
        const pairs = [{ handle: String(handle), contractAddress: CONTRACT_ADDRESS }];
        let out; try{ out = await relayer.publicDecrypt(pairs); } catch(e1){ try{ out = await relayer.publicDecrypt([String(handle)]); } catch(e2){ throw e1; } }
        let v = out[handle] ?? out[String(handle)] ?? (Array.isArray(out)? out[0] : undefined);
        if(v === undefined){ LOG.err(els.aggLog, 'Decrypt failed'); return; }
        const sumDec = Number(v); const avg = (Number(cnt||0)>0) ? (sumDec/Number(cnt)) : 0;
        els.avgChip.textContent = `Avg: ${Number.isFinite(avg)? avg.toFixed(2):'—'}`;
        LOG.ok(els.aggLog, `Decrypted sum=${sumDec}, count=${cnt}`);
      }catch(e){ LOG.err(els.aggLog, e.message||String(e)); }
    }

    // ===== Verdicts =====
    async function verdictPrivate(){
      try{
        if(!relayer || !contract) await connect();
        const t = (els.vTarget.value||"").trim(); if(!isAddr(t)) throw new Error('Enter target address');
        LOG.info(els.verLog, 'Requesting private verdict…');
        const tx = await contract.verdictPrivate(t); const rcpt = await tx.wait();
        const topic = contract.interface.getEvent('VerdictPrivate').topicHash;
        const log = rcpt.logs.find(l=>l.topics?.[0]===topic); if(!log) throw new Error('No event found');
        const parsed = contract.interface.parseLog(log); const handle = parsed.args.verdictHandle;

        // userDecrypt EIP-712
        const kp = await generateKeypair();
        const startTs = Math.floor(Date.now()/1000).toString();
        const days = '7';
        const eip = relayer.createEIP712(kp.publicKey, [CONTRACT_ADDRESS], startTs, days);
        const sig = await signer.signTypedData(eip.domain, { UserDecryptRequestVerification: eip.types.UserDecryptRequestVerification }, eip.message);
        const pairs = [{ handle: String(handle), contractAddress: CONTRACT_ADDRESS }];
        const out = await relayer.userDecrypt(pairs, kp.privateKey, kp.publicKey, sig.replace('0x',''), [CONTRACT_ADDRESS], user, startTs, days);
        const v = out[handle] ?? out[String(handle)];
        renderTier(Number(v));
        LOG.ok(els.verLog, 'Verdict decrypted (private)');
      }catch(e){ LOG.err(els.verLog, e.message||String(e)); }
    }

    async function verdictPublic(){
      try{
        if(!relayer || !contract) await connect();
        const t = (els.vTarget.value||"").trim(); if(!isAddr(t)) throw new Error('Enter target address');
        LOG.info(els.verLog, 'Requesting public verdict…');
        const tx = await contract.verdictPublic(t); const rcpt = await tx.wait();
        const topic = contract.interface.getEvent('VerdictPublic').topicHash;
        const log = rcpt.logs.find(l=>l.topics?.[0]===topic); if(!log) throw new Error('No event found');
        const parsed = contract.interface.parseLog(log); const handle = parsed.args.verdictHandle;

        // publicDecrypt
        const pairs = [{ handle: String(handle), contractAddress: CONTRACT_ADDRESS }];
        let out; try{ out = await relayer.publicDecrypt(pairs); } catch(e1){ try{ out = await relayer.publicDecrypt([String(handle)]); } catch(e2){ throw e1; } }
        const v = out[handle] ?? out[String(handle)] ?? (Array.isArray(out)? out[0] : undefined);
        renderTier(Number(v));
        LOG.ok(els.verLog, 'Verdict decrypted (public)');
      }catch(e){ LOG.err(els.verLog, e.message||String(e)); }
    }
  </script>
</body>
</html>
